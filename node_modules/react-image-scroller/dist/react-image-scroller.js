(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('emotion')) :
  typeof define === 'function' && define.amd ? define(['react', 'emotion'], factory) :
  (global.ImageScroller = factory(global.React,global.emotion));
}(this, (function (React,emotion) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      value: function value(valueToFind, fromIndex) {
        if (this == null) {
          throw new TypeError('"this" is null or not defined');
        } // 1. Let O be ? ToObject(this value).


        var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")).

        var len = o.length >>> 0; // 3. If len is 0, return false.

        if (len === 0) {
          return false;
        } // 4. Let n be ? ToInteger(fromIndex).
        //    (If fromIndex is undefined, this step produces the value 0.)


        var n = fromIndex | 0; // 5. If n ≥ 0, then
        //  a. Let k be n.
        // 6. Else n < 0,
        //  a. Let k be len + n.
        //  b. If k < 0, let k be 0.

        var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

        function sameValueZero(x, y) {
          return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
        } // 7. Repeat, while k < len


        while (k < len) {
          // a. Let elementK be the result of ? Get(O, ! ToString(k)).
          // b. If SameValueZero(valueToFind, elementK) is true, return true.
          if (sameValueZero(o[k], valueToFind)) {
            return true;
          } // c. Increase k by 1.


          k++;
        } // 8. Return false


        return false;
      }
    });
  }

  // Production steps of ECMA-262, Edition 6, 22.1.2.1
  if (!Array.from) {
    Array.from = function () {
      var toStr = Object.prototype.toString;

      var isCallable = function isCallable(fn) {
        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
      };

      var toInteger = function toInteger(value) {
        var number = Number(value);

        if (isNaN(number)) {
          return 0;
        }

        if (number === 0 || !isFinite(number)) {
          return number;
        }

        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
      };

      var maxSafeInteger = Math.pow(2, 53) - 1;

      var toLength = function toLength(value) {
        var len = toInteger(value);
        return Math.min(Math.max(len, 0), maxSafeInteger);
      }; // The length property of the from method is 1.


      return function from(arrayLike
      /*, mapFn, thisArg */
      ) {
        // 1. Let C be the this value.
        var C = this; // 2. Let items be ToObject(arrayLike).

        var items = Object(arrayLike); // 3. ReturnIfAbrupt(items).

        if (arrayLike == null) {
          throw new TypeError('Array.from requires an array-like object - not null or undefined');
        } // 4. If mapfn is undefined, then let mapping be false.


        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
        var T;

        if (typeof mapFn !== 'undefined') {
          // 5. else
          // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
          if (!isCallable(mapFn)) {
            throw new TypeError('Array.from: when provided, the second argument must be a function');
          } // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.


          if (arguments.length > 2) {
            T = arguments[2];
          }
        } // 10. Let lenValue be Get(items, "length").
        // 11. Let len be ToLength(lenValue).


        var len = toLength(items.length); // 13. If IsConstructor(C) is true, then
        // 13. a. Let A be the result of calling the [[Construct]] internal method
        // of C with an argument list containing the single item len.
        // 14. a. Else, Let A be ArrayCreate(len).

        var A = isCallable(C) ? Object(new C(len)) : new Array(len); // 16. Let k be 0.

        var k = 0; // 17. Repeat, while k < len… (also steps a - h)

        var kValue;

        while (k < len) {
          kValue = items[k];

          if (mapFn) {
            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
          } else {
            A[k] = kValue;
          }

          k += 1;
        } // 18. Let putStatus be Put(A, "length", len, true).


        A.length = len; // 20. Return A.

        return A;
      };
    }();
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteral(["\n                                    flex: 0 0 auto;\n                                    height: 100%;\n                                    width: auto;\n                                    max-width: 100%;\n                                    object-fit: contain;\n                                    overflow-y: auto;\n                                    display: block;\n                                    user-select: none;\n\n                                    * {\n                                        /* height: 100%; */\n                                        /* width: auto; */\n                                        max-width: 100%;\n                                        object-fit: contain;\n                                    }\n                                "]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["\n                            position: absolute;\n                            height: 100%;\n                            left: 0;\n                            right: 0;\n                            pointer-events: none;\n                            z-index: 20;\n                            * {\n                                pointer-events: auto;\n                            }\n                        "]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral(["\n                    height: 28em;\n                "]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }
  var FULLY_VISIBLE = 'FULLY_VISIBLE';
  var PARTIALLY_VISIBLE = 'PARTIALLY_VISIBLE';
  var NOT_VISIBLE = 'NOT_VISIBLE';

  function getStatus(items) {
    var previous = null;
    var current = [];
    var next = null;
    var prevItem;
    items.forEach(function (item) {
      // There may be any number of FULLY_VISIBLE items.
      if (item.visibility === FULLY_VISIBLE) {
        current.push(item.index);
      } // There can only be two simultaneous PARTIALLY_VISIBLE items.
      // If they are adjacent, there can be no FULLY_VISIBLE items.
      // So these two items are 'previous' and 'next'.
      else if (item.visibility === PARTIALLY_VISIBLE && prevItem && prevItem.visibility === PARTIALLY_VISIBLE) {
          previous = prevItem.index;
          next = item.index;
        } // Keep pushing 'previous' forward each iteration until one of
        // the above cases is true.
        else if (current.length === 0 && next === null) {
            previous = item.index;
          } // The item following the final FULLY_VISIBLE item is 'next'.
          else if (current.length > 0 && next === null) {
              next = item.index;
            } // Save this item to refer back to in the next iteration.


      prevItem = item;
    });
    return {
      previous: previous,
      current: current,
      next: next
    };
  }

  var ImageScroller = React__default.forwardRef(Scroller);

  function Scroller(_ref, ref) {
    var children = _ref.children,
        _ref$className = _ref.className,
        className = _ref$className === void 0 ? '' : _ref$className,
        _ref$hideScrollbar = _ref.hideScrollbar,
        hideScrollbar = _ref$hideScrollbar === void 0 ? true : _ref$hideScrollbar,
        _ref$innerClassName = _ref.innerClassName,
        innerClassName = _ref$innerClassName === void 0 ? '' : _ref$innerClassName,
        _ref$innerStyle = _ref.innerStyle,
        items = _ref.items,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$renderWithin = _ref.renderWithin,
        renderWithin = _ref$renderWithin === void 0 ? null : _ref$renderWithin,
        _ref$scrollOnClick = _ref.scrollOnClick,
        scrollOnClick = _ref$scrollOnClick === void 0 ? true : _ref$scrollOnClick,
        _ref$scrollWithArrows = _ref.scrollWithArrows,
        scrollWithArrows = _ref$scrollWithArrows === void 0 ? true : _ref$scrollWithArrows,
        _ref$scrollContainerC = _ref.scrollContainerClassName,
        scrollContainerClassName = _ref$scrollContainerC === void 0 ? '' : _ref$scrollContainerC,
        _ref$scrollContainerS = _ref.scrollContainerStyle,
        scrollContainerStyle = _ref$scrollContainerS === void 0 ? {} : _ref$scrollContainerS,
        props = _objectWithoutProperties(_ref, ["children", "className", "hideScrollbar", "innerClassName", "innerStyle", "items", "onChange", "renderWithin", "scrollOnClick", "scrollWithArrows", "scrollContainerClassName", "scrollContainerStyle"]);

    // Either `items` or `children` may be used to set scroll items (`items` has priority)
    items = items || React__default.Children.toArray(children);
    var mainRef = React.useRef(null);
    var scrollContainerRef = React.useRef(null);
    var itemsContainerRef = React.useRef(null); // Track the indices of relevant items

    var _useState = React.useState({
      previous: null,
      current: [],
      next: null
    }),
        _useState2 = _slicedToArray(_useState, 2),
        status = _useState2[0],
        setStatus = _useState2[1];

    React.useLayoutEffect(function () {
      var main = mainRef.current;
      var sc = scrollContainerRef.current;
      sc.style.overflowX = 'scroll';
      /* Manually hide the horizontal scrollbar with a hidden overflow.
         `scrollbar-width: none` is not available across-the-board at time of implementation.
      */

      if (hideScrollbar) {
        main.style.overflowY = 'hidden';
        var scrollbarWidth = main.clientHeight - sc.clientHeight;
        sc.style.height = "calc(100% + ".concat(scrollbarWidth, "px)");
      } else {
        main.style.overflowY = '';
        sc.style.height = '100%';
      }
      /* Manually limit the height of the contents of each item wrapper. There is no
         reliable CSS solution due to some weird shenanigans with the intrinsic
         height of images, or something – I'm not quite sure. I could not find a way
         to reliably limit the width of the item wrapper to its contents
         (aka shrinkwrap). Edge/IE semi-randomly set the wrapper width to the pixel
         width of the containing img instead of following the intrinsic ratio of its
         height, and Firefox/Chrome introduced a phantom padding-right when toggling
         the scrollbar (caused by extra width).
      */


      _toConsumableArray(itemsContainerRef.current.children).forEach(function (item) {
        item.style.height = "".concat(sc.clientHeight, "px");
      });
      /* Make sure renderWithin doesn't overlap the scrollContainer's scrollbar.
         `renderWithin` is absolutely positioned, so the padding and scrollbar of the
         parent element are ignored.
      */


      _toConsumableArray(sc.children).forEach(function (element) {
        element.style.maxHeight = "".concat(sc.clientHeight, "px");
      });
    }, [hideScrollbar]);
    React.useEffect(function () {
      // IntersectionObservers only report what's _changed_, so keep a list
      var intersectionRatios = new Map();
      var observer = new IntersectionObserver(observerCallback, {
        root: scrollContainerRef.current,
        threshold: [0, 0.98]
      });

      _toConsumableArray(itemsContainerRef.current.children).forEach(function (item) {
        observer.observe(item);
      });

      function observerCallback(entries) {
        // Update the current intersectionRatio of each entry
        entries.forEach(function (entry) {
          intersectionRatios.set(parseInt(entry.target.getAttribute('data-item-id'), 10), entry.intersectionRatio);
        }); // Update the status

        var items = _toConsumableArray(itemsContainerRef.current.children);

        var visibilityList = items.map(function (item) {
          var itemIndex = item.getAttribute('data-item-id');
          itemIndex = parseInt(itemIndex, 10);
          var ratio = intersectionRatios.get(itemIndex);
          var visibility;

          if (ratio > 0.98) {
            visibility = FULLY_VISIBLE;
          } else if (ratio === 0) {
            visibility = NOT_VISIBLE;
          } else visibility = PARTIALLY_VISIBLE;

          return {
            index: itemIndex,
            visibility: visibility
          };
        });
        var newStatus = getStatus(visibilityList);
        setStatus(newStatus);
        onChange(newStatus);
      }
    }, []);
    React.useEffect(function () {
      function handleKeyPress(event) {
        if (scrollWithArrows && mainRef.current.contains(event.target)) {
          if (event.key === 'ArrowRight') {
            event.preventDefault();
            next();
          } else if (event.key === 'ArrowLeft') {
            event.preventDefault();
            previous();
          }
        }
      }

      window.addEventListener('keydown', handleKeyPress);
      return function cleanUp() {
        window.removeEventListener('keydown', handleKeyPress);
      };
    }, [next, previous]);

    function next() {
      scrollTo(status.next, 'nearest');
    }

    function previous() {
      scrollTo(status.previous, 'nearest');
    }

    function scrollTo(itemIndex) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'center';

      if (itemIndex === undefined || itemIndex === null || itemIndex < 0) {
        return;
      }

      itemIndex = Math.min(itemIndex, items.length - 1);
      var mainWidth = mainRef.current.offsetWidth;
      var element = itemsContainerRef.current.children[itemIndex];
      if (!element) return; // Option A: Center the item

      if (position === 'center') {
        var margin = (mainWidth - element.offsetWidth) / 2;
        scrollContainerRef.current.scrollTo({
          top: 0,
          left: element.offsetLeft - margin,
          // parent element must be positioned
          behavior: 'smooth'
        });
      } // Option B: Fit in as many itemss as possible
      else if (position === 'nearest') {
          var fit = function fit(initialWidth, step) {
            var width = 0;

            while (true) {
              var adjacentElement = itemsContainerRef.current.children[itemIndex + step];
              if (!adjacentElement) break;
              var adjacentWidth = adjacentElement.offsetWidth;

              if (initialWidth + width + adjacentWidth < mainWidth) {
                width += adjacentWidth;
              } else {
                break;
              }

              step += step;
            }

            return width;
          };

          // Determine the direction to look first
          var step;

          if (status.current.length > 0) {
            step = itemIndex > status.current[0] ? -1 : 1;
          } else {
            step = itemIndex > status.previous ? -1 : 1;
          } // Look back and ahead to see if any other items will fit too


          var backWidth = fit(element.offsetWidth, step);
          var aheadWidth = fit(element.offsetWidth + backWidth, -step);
          var width = element.offsetWidth + backWidth + aheadWidth;

          var _margin = (mainWidth - width) / 2;

          scrollContainerRef.current.scrollTo({
            top: 0,
            left: element.offsetLeft - (step === 1 ? aheadWidth : backWidth) - _margin,
            behavior: 'smooth'
          });

          if (element.offsetLeft === 0) {
            mainRef.current.focus();
          }
        }
    }

    React.useImperativeHandle(ref, function () {
      return {
        next: next,
        previous: previous,
        scrollTo: scrollTo
      };
    }, [next, previous, scrollTo]);
    return React__default.createElement("div", _extends({
      ref: mainRef,
      tabIndex: 0
    }, props, {
      className: className + ' ' + emotion.css(_templateObject())
    }), React__default.createElement("div", _defineProperty({
      ref: scrollContainerRef,
      style: scrollContainerStyle,
      className: scrollContainerClassName
    }, "style", {
      height: '100%',
      overflowX: 'scroll'
    }), renderWithin && React__default.createElement("div", {
      className: emotion.css(_templateObject2())
    }, renderWithin({
      scrollTo: scrollTo,
      next: next,
      previous: previous,
      items: items,
      status: status
    })), React__default.createElement("div", {
      ref: itemsContainerRef,
      className: innerClassName,
      style: {
        display: 'flex',
        height: '100%',
        position: 'relative' // for measuring offset of child items

      }
    }, items.map(function (item, itemIndex) {
      return React__default.cloneElement(item, {
        'data-item-id': itemIndex,
        key: itemIndex,
        onClick: function onClick(event) {
          if (scrollOnClick) {
            event.preventDefault();

            if (status.current.includes(itemIndex)) {
              scrollTo(itemIndex, 'centre');
            } else {
              scrollTo(itemIndex, 'nearest');
            }
          }
        },
        className: emotion.css(_templateObject3()) + ' ' + (item.props.className || '')
      });
    }))));
  }

  return ImageScroller;

})));
